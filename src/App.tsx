import config from "./config";
import { initializeApp } from "firebase/app";
import { getDatabase, ref, set, onValue, update } from "firebase/database";
import { getAuth, signInAnonymously } from "firebase/auth";
import { useEffect, useState } from "react";
import "./styles/App.css";
import { message } from "antd";

import { GameData, LoginInfo, PlayerInfo } from "./types";
import references from "./utils/databaseReferences";
import GameCanvas from "./components_ui/GameCanvas";
import KeyboardListener from "./components_ui/KeyboardListener";
import MenuCard from "./components_ui/MenuCard";
import InGameCard from "./components_ui/InGameCard";

import { onDisconnectGame } from "./services/presence.service";

function App() {
	const SECONDS_BEFORE_KICK = 20;
	const [messageApi, contextHolder] = message.useMessage();
	const [loading, setLoading] = useState<boolean>(false);
	const [roomId, setRoomId] = useState<number>(1);
	const [userId, setUserId] = useState<string>(""); //uuid is now temporary. TODO: check if its still useful, and delete otherwise.
	const [ingame, setIngame] = useState<boolean>(false);
	const [gameData, setGameData] = useState<GameData | undefined>(undefined);
	const [selfPlayerInfo, setSelfPlayerInfo] = useState<PlayerInfo>({
		username: "", //will be entered in form
		position: { x: 0, y: 0 }, //default position
		color: "", //will be generated by form
	});
	const onValueFactored = () => {
		return onValue(ref(db, references.players(roomId)), (snapshot) => {
			const data: Record<string, PlayerInfo> = snapshot.val();
			setGameData({ room: roomId, playerInfo: data });
			if (data) {
				// when players all quit , the database is empty. Handle this case when the user logs on
				const playersToKick = Object.entries(data).filter(
					//TODO: this is not clean, a better solution would be to have a trigger
					// in cloud functions that deletes users when their status goes "offline"
					([id, player]) => {
						if (player.statusChangeDate) {
							return (
								player.status === "offline" &&
								player.statusChangeDate &&
								(Date.now() - player.statusChangeDate) / 1000 >= SECONDS_BEFORE_KICK
								//deletes the entry if the player has been offline for more than SECONDS_BEFORE_KICK seconds
							);
						}
					}
				);

				const updates: { [key: string]: null } = {};
				if (playersToKick.length) {
					playersToKick.forEach(([id, player]) => {
						updates[references.player(roomId, id)] = null;
					});
					update(ref(db), updates);
				}
			}
		});
	};
	useEffect(() => {
		const unsubscribe = onValueFactored();
		return () => unsubscribe();
	}, []);

	const app = initializeApp(config);
	const db = getDatabase();
	const auth = getAuth();

	const showErrorMessage = (e?: string) => {
		messageApi.open({
			type: "error",
			content: `There was an unexpected error :${e}`,
		});
		console.error(e);
		setLoading(false);
	};

	const manageEnterLobby = (values: LoginInfo) => {
		setLoading(true);
		const playerInfo: PlayerInfo = {
			username: values.username,
			position: { x: selfPlayerInfo.position.x, y: selfPlayerInfo.position.y },
			color: values.color.toHexString(),
			status: "online",
		};
		setSelfPlayerInfo(playerInfo);
		signInAnonymously(auth)
			.then((res) => {
				setUserId(res.user.uid);
				set(ref(db, references.player(roomId, res.user.uid)), playerInfo);
				onDisconnectGame(roomId, res.user.uid, db);
			})
			.then(() => {
				onValueFactored();
				setIngame(true);
				setLoading(false);
			})
			.catch((e: Error) => {
				showErrorMessage(e.message);
				setLoading(false);
			}); //TODO: Handle multiple rooms.
	};
	const backButtonOnClick = () => {
		// auth.signOut().then(() => {
		// 	// triggerOnDisconnect(roomId, userId, db);
		// 	// setUserId("");
		// 	setIngame(false);
		// });
		setIngame(false);
	};
	//player movement
	const moveSelf = (x: number, y: number) => {
		selfPlayerInfo.position.x += x;
		selfPlayerInfo.position.y += y;

		userId && //TODO: make sure the userID is saved correctly, maybe using a useEffect. For now, this will delay movement by one keystroke.
			set(ref(db, references.playerPosition(roomId, userId)), {
				x: selfPlayerInfo.position.x,
				y: selfPlayerInfo.position.y,
			}).catch((e: Error) => {
				showErrorMessage(e.message);
			});
	};

	return (
		<div className="App">
			<header className="App-header">
				{/*if we're not in the game*/}
				{!ingame && <MenuCard loading={loading} userId={userId} onFinish={manageEnterLobby} />}
				{/* if server responded correctly and there is data */}
				{ingame && gameData && (
					<div>
						<InGameCard gameData={gameData} userId={userId} backButtonOnClick={backButtonOnClick} />
						<GameCanvas gameInfo={gameData} />
					</div>
				)}

				<KeyboardListener
					handleUpPress={() => {
						moveSelf(0, 1);
					}}
					handleDownPress={() => {
						moveSelf(0, -1);
					}}
					handlelLeftPress={() => {
						//x coordinate is inverted for some reason. camera is probably upside down, but this can be put aside for now.
						moveSelf(1, 0);
					}}
					handlerRightPress={() => {
						moveSelf(-1, 0);
					}}
				/>
			</header>
		</div>
	);
}

export default App;
